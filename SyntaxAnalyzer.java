package SCL;


// SyntaxAnalyzer provides parsing of the sequence of tokens 
// to make sure sentences in the language are correct


import SCL.LexicalAnalyzer;
import SCL.Token;
import SCL.TokenType;

import java.util.ArrayList;
import java.util.List;




public class SyntaxAnalyzer {

	
	
	private LexicalAnalyzer lexer;
    private Token nextToken;
    private List<Identifier> identifiers;


    public SyntaxAnalyzer(LexicalAnalyzer lexer) {
        this.lexer = lexer;
        this.nextToken = lexer.getNextToken();
        this.identifiers = new ArrayList<>();
    }


    // parse() traverses through the list of tokens and does syntax analysis based on the rules of the language
    public void parse() {
        start();
    }


    /* start()
    Parses strings in the language generated by the rule:
    start : symbols forward_refs globals implement
     */
    private void start() {

        while (nextToken.getTokType() != TokenType.EOS_TOK) {

            if (nextToken.getTokType() == TokenType.SYMBOL_TOK) {

                // parse symbols
                symbols();
            }

            if (nextToken.getTokType() == TokenType.FORWARD_TOK) {

                // parse forward_refs
                forward_refs();
            }

            if (nextToken.getTokType() == TokenType.GLOBAL_TOK) {

                // parse globals()
                globals();
            }

            if (nextToken.getTokType() == TokenType.IMPLEMENTATIONS_TOK) {

                // parse implement()
                implement();
            }
        }


    }



    /* symbols()
    parses strings in the language generated by the rule:
    symbols :
            | symbols symbol_def
     */
    private void symbols() {
        System.out.println("Enter <symbols>");

            // parse symbols_def
            symbols_def();

            if (nextToken.getTokType() == TokenType.SYMBOL_TOK)
            // parse symbols again
            symbols();

        System.out.println("Exit <symbols>");
    }



    /* symbols_def()
    parses strings in the language generated by the rule:
    symbol_def : SYMBOL IDENTIFIER
     */
    private void symbols_def() {
        System.out.println("Enter <symbols_def>");

        // check to see if we have identifier token
        if (nextToken.getTokType() != TokenType.SYMBOL_TOK) {

            // token is not an identifier, so error
            error("symbol");

        } else {

            // get token type for identifier
            TokenType identifierTokenType = nextToken.getTokType();

            lex();

            // parse identifier
            if (nextToken.getTokType() != TokenType.ID_TOK) {
                error("Identifier");
            } else {

                // get name for identifier
                String identifierName = nextToken.getLexeme();

                lex();

                if (nextToken.getTokType() != TokenType.INT_TOK) {
                    error("Int");
                }
                 else {

                    // get value of identifier
                    String identifierValue = nextToken.getLexeme();

                    lex();

                    // add to identifier list
                    addIdentifier(identifierName, identifierValue, identifierTokenType);
                }

            }

        }

        System.out.println("Exit <symbols_def>");
    }


    /* int_literal()
    parses strings in the language generated by the rule:
    int_literal : integer
     */
    private void int_literal() {
        System.out.println("Enter <int_literal>");

        // check to see if we have identifier token
        if (nextToken.getTokType() != TokenType.INT_TOK) {

            // token is not an literal, so error
            error("int_literal");

        } else {

            lex();

        }

        System.out.println("Exit <symbols_def>");
    }



    /* forward_refs()
    parses strings in the language generated by the rule:
    forward_refs : FORWARD frefs
     */
    private void forward_refs() {
        System.out.println("Enter <forward_refs>");

            // check for FORWARD keyword
            if (nextToken.getTokType() == TokenType.FORWARD_TOK) {

                lex();

                // parse frefs
                frefs();
            }

        System.out.println("Exit <forward_refs>");
    }



    /* frefs()
    parses strings in the language generated by the rule:
    frefs : REFERENCES forward_list  |  DECLARATIONS forward_list  |  forward_list
     */
    private void frefs() {
        System.out.println("Enter <frefs>");

        // check for REFERENCES keyword and DECLARATIONS keyword
        if (nextToken.getTokType() == TokenType.REFERENCES_TOK) {

            lex();

            // parse forward_list()
            forward_list();
        }
        // check for DECLARATIONS keyword
        else if (nextToken.getTokType() == TokenType.DECLARATIONS_TOK) {

            lex();

            // parse forward_list()
            forward_list();
        } else {

            lex();

            // parse forward_list()
            forward_list();
        }

        System.out.println("Exit <frefs>");
    }



    /* forward_list()
    parses strings in the language generated by the rule:
    forward_list : forwards | forward_list forwards
     */
    private void forward_list() {
        System.out.println("Enter <forward_list>");

        // parse forwards
        forwards();


        System.out.println("Exit <forward_list>");
    }



    /* forwards()
    parses strings in the language generated by the rule:
    forwards :
         | func_main dec_parameters
         ;
     */
    private void forwards() {
        System.out.println("Enter <forwards>");

        if (nextToken.getTokType() == TokenType.FUNCTION_TOK) {

            lex();

            // parse func_main
            func_main();

            // parse param_def
            parameters();

            forward_list();
        }

        System.out.println("Exit <forwards>");
    }



    /* func_main()
    parses strings in the language generated by the rule:
    func_main :
          | FUNCTION IDENTIFIER oper_type
          | MAIN {dec_main();}
          ;
     */
    private void func_main() {
        System.out.println("Enter <func_main>");

            if (nextToken.getTokType() == TokenType.ID_TOK) {

                lex();

                // parse oper_type
                oper_type();

            } else if (nextToken.getTokType() == TokenType.MAIN_TOK) {

                lex();

            } else {
                error("identifer or Main");
            }


        System.out.println("Exit <func_main>");
    }



    /* oper_type()
    parses strings in the language generated by the rule:
    oper_type : RETURN  chk_array ret_type
          ;
     */
    private void oper_type() {
        System.out.println("Enter <oper_type>");

        // check for RETURN keyword, if not error
        if (nextToken.getTokType() != TokenType.RETURN_TOK) {

            error("Return");

        } else {

            lex();

            // parse chk_array
            chk_array();

            // parse ret_type
            ret_type();

        }

        System.out.println("Exit <oper_type>");
    }



    /* chk_array()
    parses strings in the language generated by the rule:
    chk_array :
          | ARRAY array_dim_list
          ;
     */
    private void chk_array() {
        System.out.println("Enter <chk_array>");

        // check for ARRAY keyword
        if (nextToken.getTokType() == TokenType.ARRAY_TOK) {

            lex();

            // parse array_dim_list
            array_dim_list();
        }



        System.out.println("Exit <chk_array>");
    }



    /* ret_type()
    parses strings in the language generated by the rule:
    ret_type  : TYPE type_name
          | STRUCT IDENTIFIER
          | STRUCTYPE IDENTIFIER
          ;
     */
    private void ret_type() {
        System.out.println("Enter <ret_type>");

        // check for TYPE keyword
        if (nextToken.getTokType() == TokenType.TYPE_TOK) {

            lex();

            // parse type_name
            type_name();

        }
        // check for STRUCT keyword
        else if (nextToken.getTokType() == TokenType.STRUCT_TOK) {

            lex();


            // check for identifier
            if (nextToken.getTokType() != TokenType.ID_TOK) {

                // display error
                error("identifier");

            }
            else {

                lex();
            }
        }
        // didnt get correct keywords, so error
        else {

            error("Type or Struct");

        }

        System.out.println("Exit <ret_type>");
    }



    /* array_dim_list()
    parses strings in the language generated by the rule:
    array_dim_list : LB array_index RB
                   | array_dim_list LB array_index RB
                   ;
     */
    private void array_dim_list() {
        System.out.println("Enter <array_dim_list>");

        if (nextToken.getTokType() == TokenType.LEFTBRACKET_TOK) {

            lex();

            // parse array_index
            array_index();

            if (nextToken.getTokType() == TokenType.RIGHTBRACKET_TOK) {

                lex();

            } else {

                // expected right bracket but got something else, error
                error("]");

            }
        }

        System.out.println("Exit <array_dim_list>");
    }



    /* array_dim_list()
    parses strings in the language generated by the rule:
    array_dim_list : LB array_index RB
                   | array_dim_list LB array_index RB
                   ;
 */
    private void array_index() {
        System.out.println("Enter <array_index>");

        // check for identifier, if not error
        if (nextToken.getTokType() != TokenType.ID_TOK) {

            error("Identifier");

        } else {

            lex();
        }

        System.out.println("Exit <array_index>");
    }




    /* type_name()
    parses strings in the language generated by the rule:
    type_name       : MVOID
                    | INTEGER
                    | SHORT
                    ;
    */
    private void type_name() {
        System.out.println("Enter <type_name>");

        // check for integer, if no integer display error
        if (nextToken.getTokType() != TokenType.INTEGER_TOK) {

            error("Integer");

        }

        else {

            lex();

        }


        System.out.println("Exit <type_name>");
    }




    // ------------------------------------------------ globals



    /* globals()
    parses strings in the language generated by the rule:
    globals :
        | GLOBAL declarations
        ;
    */
    private void globals() {
        System.out.println("Enter <globals>");

        if (nextToken.getTokType() == TokenType.GLOBAL_TOK) {

            lex();

            // parse declarations
            declarations();
        }

        System.out.println("Exit <globals>");
    }




    /* declarations()
    parses strings in the language generated by the rule:
    declarations :
             | DECLARATIONS const_dec var_dec
             ;
    */
    private void declarations() {
        System.out.println("Enter <declarations>");

        if (nextToken.getTokType() == TokenType.DECLARATIONS_TOK) {

            lex();

            // parse const_dec
            const_dec();

            // parse var_dec
            var_dec();
        }

        System.out.println("Exit <declarations>");
    }



    /* const_dec()
    parses strings in the language generated by the rule:
    const_dec : CONSTANTS const_list
          ;
    */
    private void const_dec() {
        System.out.println("Enter <const_dec>");

        if (nextToken.getTokType() != TokenType.CONSTANTS_TOK) {

            error("CONSTANTS");

        } else {

            lex();

            // parse const_list
            const_list();

        }

        System.out.println("Exit <const_dec>");
    }



    /* const_list()
    parses strings in the language generated by the rule:
    const_list : const_list DEFINE identifier rec_type equal_op constant_val
           ;
*/
    private void const_list() {
        System.out.println("Enter <const_list>");


        // check for DEFINE keyword
        if (nextToken.getTokType() != TokenType.DEFINE_TOK) {

            error("DEFINE");

        } else {

                lex();

                // parse identifier
                identifier();

                // parse rec_type
                ret_type();

                // parse equal_op
                equal_op();

                // parse constant_val
                constant_val();

                if (nextToken.getTokType() == TokenType.DEFINE_TOK)

                    // parse const_list again
                    const_list();

        }

        System.out.println("Exit <const_list>");
    }


    /* identifier()
    parses strings in the language generated by the rule:
    identifier : ID_TOK
        ;
    */
    public void identifier() {
        System.out.println("Enter <identifier>");

        if (nextToken.getTokType() != TokenType.ID_TOK) {
            error("Identifier");
        } else {


            lex();
        }
        System.out.println("Exit <identifier>");
    }



    /* equal_op()
    parses strings in the language generated by the rule:
    equal_op : =
        ;
    */
    public void constant_val() {
        System.out.println("Enter <constant_val>");

        if (nextToken.getTokType() != TokenType.INT_TOK) {
            error("Constant Value");
        } else {

            lex();

        }

        System.out.println("Exit <constant_val>");
    }



    /* equal_op()
    parses strings in the language generated by the rule:
    constant_val : integer
        ;
    */
    public void equal_op() {
        System.out.println("Enter <equal_op>");

        if (nextToken.getTokType() != TokenType.ASSIGN_TOK) {
            error("=");
        } else {

            lex();

        }

        System.out.println("Exit <equal_op>");
    }



    /* var_dec()
    parses strings in the language generated by the rule:
    var_dec : VARIABLES var_list
        ;
    */
    private void var_dec() {
        System.out.println("Enter <var_dec>");


        if (nextToken.getTokType() != TokenType.VARIABLES_TOK) {
            error("VARIABLES");
        } else {

            lex();

            // parse var_list
            var_list();

        }

        System.out.println("Exit <var_dec>");
    }



    /* var_list()
    parses strings in the language generated by the rule:
    var_list : var_list DEFINE identifier rec_type
         ;
    */
    private void var_list() {
        System.out.println("Enter <var_list>");

        if (nextToken.getTokType() != TokenType.DEFINE_TOK) {
            error("DEFINE");
        } else {

            lex();

            // parse identifier
            identifier();

            // parse rec_type
            ret_type();


            if (nextToken.getTokType() == TokenType.DEFINE_TOK)

                // parse var_list again
                var_list();

        }

        System.out.println("Exit <var_list>");
    }




    // ------------------------------------------------ implementation


    /* implement()
    parses strings in the language generated by the rule:
    implement : IMPLEMENTATIONS funct_list
          ;
    */
    private void implement() {
        System.out.println("Enter <implement>");

        if (nextToken.getTokType() != TokenType.IMPLEMENTATIONS_TOK) {

            error("IMPLEMENT");

        } else {

            lex();

            // parse func_list
            funct_list();
        }

        System.out.println("Exit <implement>");
    }


    /* funct_list()
    parses strings in the language generated by the rule:
    funct_list : funct_def
           | funct_list funct_def
           ;
    */
    private void funct_list() {
        System.out.println("Enter <funct_list>");

        funct_def();

        if (nextToken.getTokType() == TokenType.FUNCTION_TOK) {
            funct_def();
        }

        System.out.println("Exit <funct_list>");
    }



    /* funct_def()
    parses strings in the language generated by the rule:
    funct_list : funct_def
           | funct_list funct_def
           ;
    */
    private void funct_def() {
        System.out.println("Enter <funct_def>");

        // parse funct_body
        funct_body();


        System.out.println("Exit <funct_def>");
    }



    /* funct_body()
   parses strings in the language generated by the rule:
   funct_list : funct_def
          | funct_list funct_def
          ;
   */
    private void funct_body() {
        System.out.println("Enter <funct_body>");

        if (nextToken.getTokType() != TokenType.FUNCTION_TOK) {
            error("FUNCTION");
        } else {

            lex();

            // parse main_head
            main_head();

            // parse parameters
            parameters();

            // parse f_body
            f_body();
        }


        System.out.println("Exit <funct_body>");
    }




    /* main_head()
    parses strings in the language generated by the rule:
    main_head : MAIN
          | IDENTIFIER
          ;
    */
    private void main_head() {
        System.out.println("Enter <main_head>");

        if (nextToken.getTokType() == TokenType.MAIN_TOK) {

            lex();

        }

        else if (nextToken.getTokType() == TokenType.ID_TOK) {

            lex();

        }

        else {
            error("MAIN or ID");
        }

        System.out.println("Exit <main_head>");
    }




    /* parameters()
    parses strings in the language generated by the rule:
    parameters :
           | PARAMETERS param_list
           ;
    */
    private void parameters() {
        System.out.println("Enter <parameters>");

        if (nextToken.getTokType() != TokenType.PARAMETERS_TOK) {
            error("PARAMETERS");
        }

        else {

            lex();

            // parse param_list
            param_list();
        }

        System.out.println("Exit <parameters>");
    }




    /* param_list()
    parses strings in the language generated by the rule:
    param_list : param_def
           | param_list COMMA param_def
           ;
    */
    private void param_list() {
        System.out.println("Enter <param_list>");

        param_def();


        System.out.println("Exit <param_list>");
    }



    /* param_def()
    parses strings in the language generated by the rule:
    param_def : identifier chk_const chk_ptr chk_array TYPE type_name
          ;
    */
    private void param_def() {
        System.out.println("Enter <param_def>");

        if (nextToken.getTokType() != TokenType.ID_TOK) {

            error("Identifier");

        } else {

            // parse identifier
            identifier();

            if (nextToken.getTokType() != TokenType.TYPE_TOK) {
                error("Type");
            } else {

                lex();

                // parse type name
                type_name();

            }


        }

        System.out.println("Exit <param_def>");
    }



    /* chk_const()
    parses strings in the language generated by the rule:
    chk_const :
          | CONSTANT
          ;
    */
    private void chk_const() {
        System.out.println("Enter <chk_const>");

        if (nextToken.getTokType() != TokenType.CONSTANTS_TOK) {
            error("CONSTANT");
        }
        else {

            lex();
        }


        System.out.println("Exit <chk_const>");
    }



    /* f_body()
    parses strings in the language generated by the rule:
    f_body : declarations BEGIN <statement_list> ENDFUN
       ;
    */
    private void f_body() {
        System.out.println("Enter <f_body>");

        // parse declarations
        declarations();

        if (nextToken.getTokType() != TokenType.BEGIN_TOK) {
            error("BEGIN");
        } else {

            lex();

            // parse statement_list
            statement_list();

            if (nextToken.getTokType() != TokenType.ENDFUN_TOK) {
                error("BEGIN");
            } else {

                lex();

            }
        }
        System.out.println("Exit <f_body>");
    }



    /* statement_list()
    parses strings in the language generated by the rule:
    statement_list : statement
               | statement_list statement
               ;
    */
    private void statement_list() {
        System.out.println("Enter <statement_list>");

        //TODO fix while loop


        //parse statement
        statement();


        System.out.println("Exit <statement_list>");
    }



    /* statement_list()
    parses strings in the language generated by the rule:
    statement : if_statement
          | assignment_statement
		  | while_statement
		  | print_statement
		  | repeat_statement
          ;
    */
    private void statement() {
        System.out.println("Enter <statement>");

        if (nextToken.getTokType() == TokenType.IF_TOK) {

            lex();

            // parse if_statement
            if_statement();
        }

        else if (nextToken.getTokType() == TokenType.SET_TOK) {

            lex();

            // parse if_statement
            assignment_statement();
        }

        else if (nextToken.getTokType() == TokenType.WHILE_TOK) {

            lex();

            // parse while_statement
            while_statement();
        }

        else if (nextToken.getTokType() == TokenType.REPEAT_TOK) {

            lex();

            // parse repeat_statement
            repeat_statement();

        }


        System.out.println("Exit <statement>");
    }




    /* if_statement()
    parses strings in the language generated by the rule:
    if_statement : IF boolean_expression THEN statement_list
      ELSE statement_list ENDIF
    */
    private void if_statement() {
        System.out.println("Enter <if_statement>");

            // parse boolean_expression
            boolean_expression();

            if (nextToken.getTokType() != TokenType.THEN_TOK) {
                error("THEN");
            } else {

                lex();

                // parse statement_list
                statement_list();

                if (nextToken.getTokType() == TokenType.ENDIF_TOK) {

                    lex();

                } else if (nextToken.getTokType() == TokenType.ELSE_TOK) {

                    lex();

                    // parse statement_list
                    statement_list();


                } else {
                    error("ENDIF or ELSE");
                }
            }


        System.out.println("Exit <if_statement>");
    }



    /* while_statement()
    parses strings in the language generated by the rule:
    while_statement : WHILE boolean_expression DO statement_list ENDWHILE
                ;
    */
    private void while_statement() {
        System.out.println("Enter <while_statement>");

            // parse boolean_expression
            boolean_expression();

            if (nextToken.getTokType() != TokenType.DO_TOK) {
                error("DO");
            } else {

                lex();

                // parse statement_list
                statement_list();

                if (nextToken.getTokType() != TokenType.ENDWHILE_TOK) {
                    error("ENDWHILE");
                } else {

                    lex();

                }
            }

        System.out.println("Exit <while_statement>");
    }



    /* assignment_statement()
    parses strings in the language generated by the rule:
    assignment_statement : SET identifier assignment_operator arithmetic_expression
                     ;
    */
    private void assignment_statement() {
        System.out.println("Enter <assign_statement>");


        if (nextToken.getTokType() != TokenType.ID_TOK) {
            error("Identifier");
        } else {

            lex();

            if (nextToken.getTokType() != TokenType.ASSIGN_TOK) {
                error("=");
            } else {

                lex();

                // parse arithmetic_expression
                arithmetic_exp();
            }


        }

        System.out.println("Exit <assignment_statement>");
    }





    /* repeat_statement()
    parses strings in the language generated by the rule:
    repeat_statement : REPEAT statement_list UNTIL boolean_expression ENDREPEAT
                 ;
    */
    private void repeat_statement() {
        System.out.println("Enter <repeat_statement>");

        //TODO

        System.out.println("Exit <repeat_statement>");
    }




    /* boolean_expression()
    parses strings in the language generated by the rule:
    boolean_expression : arithmetic_exp relative_op arithmetic_exp
    */
    private void boolean_expression() {
        System.out.println("Enter <boolean_expression>");

        // parse arithmetic_exp
        arithmetic_exp();

        // parse relative_op
        relative_op();

        // parse arithmetic_exp
        arithmetic_exp();

        System.out.println("Exit <boolean_expression>");
    }



    /* arg_list()
    parses strings in the language generated by the rule:
    arg_list : args
         | arg_list comma args
		 ;
    */
    private void arg_list() {
        System.out.println("Enter <arg_list>");

        //TODO recursion
        // parse args
        args();

        System.out.println("Exit <arg_list>");
    }




    /* args()
    parses strings in the language generated by the rule:
    args : identifier
     | constant
     | string
	 ;
    */
    private void args() {
        System.out.println("Enter <args>");

        if (nextToken.getTokType() != TokenType.ID_TOK || nextToken.getTokType() != TokenType.INT_TOK) {
            error("identifier or constant");
        } else {

            lex();
        }


        System.out.println("Exit <args>");
    }



    /* relative_op()
    parses strings in the language generated by the rule:
    relative_op : le_operator | lt_operator | ge_operator | gt_operator | eq_operator | ne_operator
                ;
    */
    private void relative_op() {
        System.out.println("Enter <relative_op>");

        if (nextToken.getTokType() == TokenType.LE_TOK) {

            lex();
        }

        else if (nextToken.getTokType() == TokenType.LT_TOK) {

            lex();
        }

        else if (nextToken.getTokType() == TokenType.GE_TOK) {

            lex();
        }
        else if (nextToken.getTokType() == TokenType.GT_TOK) {

            lex();
        }
        else if (nextToken.getTokType() == TokenType.EQ_TOK) {

            lex();
        }
        else if (nextToken.getTokType() == TokenType.NE_TOK) {

            lex();
        }
        else {

            // error
            error("relative operator");
        }

            System.out.println("Exit <relative_op>");
    }




    /* arithmetic_exp()
    parses strings in the language generated by the rule:
    arithmetic_exp : arithmetic_exp add_operator mulexp
               | arithmetic_exp sub_operator mulexp
			   | mulexp
			   ;
    */
    private void arithmetic_exp() {
        System.out.println("Enter <arithmetic_expression>");

        if (nextToken.getTokType() != TokenType.INT_TOK) {
            error("int_literal");
        }

         else {

            lex();
        }



        System.out.println("Exit <arithmetic_expression>");
    }









    private void lex() {
        // show the token
        printToken();

        // consume token
        nextToken = lexer.getNextToken();
    }


    private void printToken() {
        System.out.println();
        System.out.printf("   Next token is: %s (%s) lexeme is: %s \n", nextToken.getTokType(), nextToken.getTokCode(), nextToken.getLexeme());
        System.out.println();
    }

    private void error(String s) {
        System.out.println("Invalid Syntax Error at line: " + nextToken.getRowNumber() + " col: " + nextToken.getColNumber() + " Expected \"" + s + "\" and received: \"" + nextToken.getLexeme() + "\" of Type: " + nextToken.getTokType());

    }


    /* addIdentifier()
    checks to see if identifier already exists
    if not, attemps to add to the list
     */
    private void addIdentifier(String identifierName, String identifierValue, TokenType identifierToken) {

        boolean alreadyExists = false;

        // check to see if the identifier already exists
        for (Identifier i : identifiers) {
            if (i.getName().contains(identifierName)) {
                alreadyExists = true;
                System.out.println("Error:  Duplicate identifier error.  Already assigned: " + i.getName());
                System.out.println();
            }
        }

        if (alreadyExists == false) {
            identifiers.add(new Identifier(identifierName, identifierValue, identifierToken));
        }


    }
	
	
	
	
	
	
}
